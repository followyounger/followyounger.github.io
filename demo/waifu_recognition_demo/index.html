---
title: Demo
layout: default
nav-style: "invert"
projectTitle: 'Waifu_Recognition'
hide-in-nav: true
---

{% include intro-header.html type='demo'%}

{% if site.disqus_username %}
<link rel="stylesheet" href="/css/iDisqus.min.css" />
<script src="/js/iDisqus.min.js"></script>
{% endif %}


<!-- Post Content -->
<article xmlns:display="http://www.w3.org/1999/xhtml">
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <div class="post-content">
                    <div class="reproduce-block">
                        <p>The demo is built and demonstrated by <a href="https://www.tensorflow.org/js/" aria-label="TensorFlowjs">TensorFlowjs</a>, a library for developing and training ML models in JavaScript, and deploying in browser or on Node.js </p>
                    </div>
                    <p>Detect faces and key points of anime characters. Training data is obtained from <a href="https://www.obormot.net/demos/these-waifus-do-not-exist-alt" aria-label="These Waifus Do Not Exist">These Waifus Do Not Exist</a> . With only 147 labeled train images, the model had been trained for 12 hours on GTX 1080ti and reached a accuracy of 96%. </p>
                    <p>Because the images on <a href="https://www.obormot.net/demos/these-waifus-do-not-exist-alt" aria-label="These Waifus Do Not Exist">These Waifus Do Not Exist</a> are all avatars so the model will be not that accuracy when  playing on the whole body image. </p>
                    <p>However as i also upload checkpoints, you can continue to train if you want better accuracy or full-body detection.</p>
                    <p><img id="img" class="demo-image" src="" alt="Demo Image" /></p>
                    <canvas id="canvas" style="pointer-events: none"></canvas>
                    <p><input type="submit" id="demo_waifu_rand_btn" class="demo-btn" value="Random Image" onclick="img.setAttribute('src', randomlyGetWaifu());"/></p>
                    <p><input type="submit" id="demo_waifu_pred_btn" class="demo-btn" value="Predict" onclick="predict()"/></p>
                    <p><input type="submit" id="demo_waifu_toggle_btn" class="demo-btn" value="Toggle Layer" onclick="toggleLayer()"/></p>
                    <div class="reproduce-block">
                        <h3>Helper</h3>
                        <p>Running the model for the first time can take a long time, because the model will not only need to be loaded from the cloud for the first time, but also needs to be warmed up.</p>
                        <br>
                        <p><code class="highlighter-rouge">RANDOM IMAGE</code> button to change the test image randomly.</p>
                        <p><code class="highlighter-rouge">PREDICT</code> button to detect image key information.</p>
                        <p><code class="highlighter-rouge">TOGGLE LAYER</code> button to turn on or turn off canvas layer after predicting.</p>
                        <br>
                        <p><strong>Highly recommended to use modern browsers such as Google Explorer or Safari and please update to the latest version for the best experience </strong></p>
                    </div>
                </div>

                <hr style="visibility: hidden;">

                <br>

                <hr style="visibility: hidden;">

                {% if site.disqus_username %}
                <div id="comment"></div>
                {% endif %}
            </div>
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                {% include featured-tags.html bottom=true %}

                <!-- Friends Blog -->
                {% include friends.html %}
            </div>

        </div>
    </div>
</article>




{% if site.disqus_username %}
<script>
    var disq = new iDisqus('comment', {
        forum: 'soptlog',
        api: 'https://api.soptq.me/disqus/api',
        site: 'https://soptq.me',
        identifier: window.location.href.split('?')[0],
        url: window.location.href.split('?')[0],
        mode: 1,
        timeout: 3000,
        init: true,
        emojiPreview: true
    });
</script>
{% endif %}

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.5/dist/tf.js"> </script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@0.8.0/dist/tf-converter.js"></script>

<script>
    const MODEL_URL = 'https://server.soptq.me/blog/models/waifu_recognition/tensorflowjs_model.pb';
    const WEIGHTS_URL = 'https://server.soptq.me/blog/models/waifu_recognition/weights_manifest.json';

    const img_url_base = '/demo/waifu_recognition_demo/images/';

    btn_pred = document.getElementById('demo_waifu_pred_btn');
    btn_toogle = document.getElementById('demo_waifu_toggle_btn');
    btn_toogle.disabled = true;
    img = document.getElementById('img');
    canvas = document.getElementById('canvas');

    let ctx = canvas.getContext("2d");

    var PREDICTION = [];

    const dpr = window.devicePixelRatio || 1,
        bsr = ctx.webkitBackingStorePixelRatio ||
            ctx.mozBackingStorePixelRatio ||
            ctx.msBackingStorePixelRatio ||
            ctx.oBackingStorePixelRatio ||
            ctx.backingStorePixelRatio || 1;

    function getRatio() {
        return dpr / bsr;
    }

    canvas.style.left = img.offsetLeft + "px";
    canvas.style.top = img.offsetTop + "px";
    canvas.style.width = img.width + "px";
    canvas.style.height = img.height + "px";
    canvas.width = img.width * getRatio();
    canvas.height = img.height * getRatio();

    canvas.style.position = "absolute";

    function resizedw() {
        canvas.style.left = img.offsetLeft + "px";
        canvas.style.top = img.offsetTop + "px";
        canvas.style.width = img.width + "px";
        canvas.style.height = img.height + "px";
        canvas.width = img.width * getRatio();
        canvas.height = img.height * getRatio();
    }

    window.addEventListener('resize', function () {
        clearTimeout(doit);
        doit = setTimeout(resizedw, 500);
    });

    function calculateMaxScores(scores , numBoxes, numClasses) {
        const maxes = [];
        const classes = [];
        for (let i = 0; i < numBoxes; i++) {
            let max = Number.MIN_VALUE;
            let index = -1;
            for (let j = 0; j < numClasses; j++) {
                if (scores[i * numClasses + j] > max) {
                    max = scores[i * numClasses + j];
                    index = j;
                }
            }
            maxes[i] = max;
            classes[i] = index;
        }
        return [maxes, classes];
    }

    function getDisplayName(i) {
        switch (i) {
            case 0:
                return "Face";
            case 1:
                return "Eye";
            case 2:
                return "Nose";
            case 3:
                return "Mouth";
        }
    }

    function getClass(str) {
        if (str === 'Face'){
            return 0;
        } else if (str === 'Eye'){
            return 1;
        }else if (str === 'Nose') {
            return 2;
        }else if (str === 'Mouth'){
            return 3;
        }
    }


    function buildDetectedObjects(width, height, boxes, scores, indexes, classes){
        const count = indexes.length;
        const objects = [];
        for (let i = 0; i < count; i++) {
            const bbox = [];
            for (let j = 0; j < 4; j++) {
                bbox[j] = boxes[indexes[i] * 4 + j];
            }
            const minY = bbox[0] * canvas.height;
            const minX = bbox[1] * canvas.width;
            const maxY = bbox[2] * canvas.height;
            const maxX = bbox[3] * canvas.width;
            bbox[0] = minX;
            bbox[1] = minY;
            bbox[2] = maxX - minX;
            bbox[3] = maxY - minY;
            objects.push({
                bbox: bbox,
                class: getDisplayName(classes[indexes[i]]),
                score: scores[indexes[i]]
            });
        }
        PREDICTION = objects;
        return objects;
    }


    async function object_detection(img){
        const maxNumBoxes = 20;
        const model = await tf.loadFrozenModel(MODEL_URL, WEIGHTS_URL);
        const image = tf.fromPixels(img);
        const pixels = image.reshape([1, ...image.shape]);
        const executeresult = model.executeAsync(pixels);
        const height = image.shape[0];
        const width = image.shape[1];
        executeresult.then(function(value){
            tensorarray = value;
            const scores = tensorarray[0].dataSync();
            const boxes = tensorarray[1].dataSync();
            const [maxScores, classes] = this.calculateMaxScores(scores, tensorarray[0].shape[1], tensorarray[0].shape[2]);
            const prevBackend = tf.getBackend();
            tf.setBackend('cpu');
            const indexTensor = tf.tidy(() => {
                const boxes2 =
                    tf.tensor2d(boxes, [tensorarray[1].shape[1], tensorarray[1].shape[3]]);
                return tf.image.nonMaxSuppression(
                    boxes2, maxScores, maxNumBoxes, 0.5, 0.5);
            });
            const indexes = indexTensor.dataSync();
            indexTensor.dispose();
            // restore previous backend
            tf.setBackend(prevBackend);
            this.buildDetectedObjects(width, height, boxes, maxScores, indexes, classes);
            drawRendered(img, canvas);
            return PREDICTION
        }, function(error){});
    }

    function drawRendered(){
        colorList = ["#00c853", "#2962ff", "#d50000", "#3e2723"];
        const length = PREDICTION.length;
        const fontstr = 15 * getRatio() + "px PT Sans";
        for (let i = 0; i < length; i++){
            ctx.beginPath();
            ctx.rect(PREDICTION[i]["bbox"][0], PREDICTION[i]['bbox'][1], PREDICTION[i]["bbox"][2], PREDICTION[i]["bbox"][3]);
            ctx.lineWidth = 3 * getRatio();
            ctx.strokeStyle = colorList[getClass(PREDICTION[i]['class'])];
            ctx.stroke();
            ctx.beginPath();
            ctx.fillStyle = colorList[getClass(PREDICTION[i]['class'])];
            ctx.fillRect(PREDICTION[i]["bbox"][0] - 1, PREDICTION[i]['bbox'][1], 90 * getRatio() , -40 * getRatio());
            ctx.stroke();
            ctx.font = fontstr;
            ctx.fillStyle = "#FFFFFF";
            ctx.fillText(PREDICTION[i]['class'], PREDICTION[i]["bbox"][0] + 5, PREDICTION[i]['bbox'][1] - 5 * getRatio());
            ctx.fillText(PREDICTION[i]['score'].toString().substring(0,10), PREDICTION[i]["bbox"][0] + 5, PREDICTION[i]['bbox'][1] - 23 * getRatio());
        }
        btn_pred.setAttribute('value', 'Complete');
        btn_toogle.disabled = false;
    }

    function rnd(n, m){
        return Math.floor(Math.random()*(m-n+1)+n).toString();
    }

    function randomlyGetWaifu(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        btn_pred.disabled = false;
        btn_toogle.disabled = true;
        btn_pred.setAttribute('value', 'Predict');
        postfix = img_url_base + 'image-' + rnd(1, 170) + '.jpg';
        return postfix;
    }
    

    img.setAttribute("src", randomlyGetWaifu());
    function predict(){
        btn_pred.disabled = true;
        btn_pred.setAttribute('value', 'Predicting...It can take up to 2 mins');
        canvas.style.left = img.offsetLeft + "px";
        canvas.style.top = img.offsetTop + "px";
        canvas.style.width = img.width + "px";
        canvas.style.height = img.height + "px";
        canvas.width = img.width * getRatio();
        canvas.height = img.height * getRatio();
        object_detection(img);
    }

    function toggleLayer(){
        canvas.classList.toggle('hidden');
    }
</script>
